pragma solidity ^0.4.11;

import 'zeppelin-solidity/contracts/math/SafeMath.sol';
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

contract usingDataFeeds is usingOraclize {
    using SafeMath for uint256;

    // Defining public variables assigned here but later used in the TokenOFGratitude contract
    uint public rateAge;
    address public owner;
    uint256 public luckyNumber;
    uint256 public donors;
    bool public haveRandom;

    // Defining helper variables to differentiate Oraclize queries
    bytes32 qID1;
    bytes32 qID2;

    /**
     * @dev Create the ETHUSD query to Kraken though Oraclize
     * @dev There has to be a TODO: finish docs
     */
    function getRateUSD() internal {

        //require(msg.sender == owner);
        oraclize_setProof(proofType_TLSNotary);
        if (oraclize.getPrice("URL") > this.balance) {
            newOraclizeQuery("Oraclize: Insufficient funds!"");
        } else {
            newOraclizeQuery("Oraclize was asked for ETHUSD rate.");
            qID1 = oraclize_query("URL", "json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.p.1",100000);
        }
    }

    /**
     * @dev Create the random number query to Oraclize
     * @param  There has to be a TODO: finish docs
     */
    function getRandom() internal {

        //require (msg.sender == owner);
        oraclize_setProof(proofType_Ledger);
        if (oraclize.getPrice("") > this.balance) {
            newOraclizeQuery("Oraclize: Insufficient funds!");
        } else {
            newOraclizeQuery("Oraclize was asked for a random number.");

            // Make query for 4 random bytes to potentially get a number between 0 and 4294967295.
            // The assumption is that there won't be more then 4294967295 participants.
            // This may potentially hurt your contract as the "random mod participants" result distribution is unequal.
            // There creates an incentive to join earlier to have an micro advantage.
            qID2 = oraclize_newRandomDSQuery(0, 4, 100000);
        }
    }

    /**
     *Oraclize callback function awaiting for response from the queries
     * @dev uses qType to handle the last called query type
     * @dev different querytypes shouldn't be called before callback was received
     * @dev -> not implementing a query que as "owner" is the only party responsible for creating order
     *      - BEAR THAT IN MIND
     */
    function __callback(bytes32 myid, string result, bytes proof) {
        require(msg.sender == oraclize_cbAddress());

    if (myid == qID1) {
        checkQueryA(myid, result, proof);
    } else if (myid == qID2) {
        checkQueryB(myid, result, proof);
    }
    }

    /**
     * A helper function to separate reaction to different Oraclize queries - ETHUSD rate
     * @dev reaction to ETHUSD rate oraclize callback - getRateUSD()
     * @dev sets global vars rate to the result and rateAge to current timeStamp
     * @param _myid 32 bytes identifying the query generated by Oraclize
     * @param _result string with query result by Oraclize
     * @param _proof byte array with the proof of source by Oraclize
     */
    function checkQueryA(bytes32 _myid, string _result, bytes _proof) internal {
        newRate(_result);

        // calling Oraclize string => uint256 converter for a number with 4 decimals
        rate = parseInt(_result,4);
        rateAge = now;
    }

    /**
     * A helper function to separate reaction to different Oraclize queries - random number
     * @dev reaction to random number oraclize callback - getRandom(number of participants)
     * @dev sets global var luckyNumber to the result
     * @param _myid 32 bytes identifying the query generated by Oraclize
     * @param _result string with query result by Oraclize
     * @param _proof byte array with the proof of source by Oraclize
     */
    function checkQueryB(bytes32 _queryId, string _result, bytes _proof) internal oraclize_randomDS_proofVerify(_queryId, _result, _proof) {
        newRandom(_result);

        // Calling Oraclize string => uint converter
        someNumber = parseInt(string(bytes(_result)),0);

        // Getting a luckyNumber between 0 and the number of donors (Random-number modulo number of donors)
        luckyNumber = someNumber%donors;
        haveRandom = true;
    }

    // Oraclize related events
    event newOraclizeQuery(string description);
    event newRate(string price);
    event newRandom(string price);
}